# BundleScanner.py (.base)
import sys
#SUPERIMPORT IMPORT_utils.py
#SUPERIMPORT IMPORT_db.py

#SUPERIMPORT CODE_utils.py
#SUPERIMPORT CODE_db.py


########################################################
# Define Phases for Main

# Phase 0
# Look for space usage
# Log the space usage and date
# Done w/ phase 0
def Phase0():
    #storageArea = '/var/log'
    storageArea = '/mnt/lfss'
    command = ['/bin/df', '-BG', storageArea]
    ErrorString = ''
    outp, erro, code = getoutputerrorsimplecommand(command, 1)
    if int(code) != 0:
        ErrorString = ErrorString + ' Failed to df '
    else:
        lines = outp.decode("utf-8").splitlines()
        size = -1
        for line in lines:
            if storageArea in str(line):
                words = line.split()
                try:
                    sizeword = words[len(words)-3]
                    size = int(sizeword[0:-1])  # remove trailing G
                except:
                    ErrorString = ErrorString + ' Failed to df '
    #print(size)
    if len(ErrorString) > 0:
        posturl = copy.deepcopy(basicposturl)
        posturl.append(targetsetdumperror + mangle(ErrorString))
        answer = getoutputsimplecommandtimeout(posturl, 1)
        return
    posturl = copy.deepcopy(basicposturl)
    posturl.append(targetsetdumppoolsize + str(size))
    answer = getoutputsimplecommandtimeout(posturl, 1)
    danswer = massage(answer)
    if 'OK' not in danswer:
        print(answer)
        posturl = copy.deepcopy(basicposturl)
        posturl.append(targetsetdumperror + mangle('Failed to set poolsize'))
        answer = getoutputsimplecommandtimeout(posturl, 1)
        return
    return

#targetsetdumperror = curltargethost + '/dumpcontrol/update/bundleerror/'
#targetsetdumpstatus = curltargethost + '/dumpcontrol/update/status/'
#targetsetdumppoolsize = curltargethost + '/dumpcontrol/update/poolsize/'
# 
# Phase 1	Look for problem files
# ls /mnt/data/jade/problem_files/globus-mirror
# If GLOBUS_PROBLEM_SPACE
# If alert file is only file present, delete it and we're done
# foreach .json file in the list
#    Update BundleStatus for each with 'PushProblem'
# Update CandC with status='Error', bundleError='problem_files'
# Done with phase 1
def Phase1():
    command = ['/bin/ls', GLOBUS_PROBLEM_SPACE]
    ErrorString = ''
    outp, erro, code = getoutputerrorsimplecommand(command, 1)
    if int(code) != 0:
        posturl = copy.deepcopy(basicposturl)
        posturl.append(targetsetdumperror + mangle(' Failed to ls ' + GLOBUS_PROBLEM_SPACE))
        answer = getoutputsimplecommandtimeout(posturl, 1)
        return
    # If here, ls worked ok.
    lines = outp.decode("utf-8").splitlines()
    if len(lines) == 0:
        return	# OK, nothing to do
    for line in lines:
        if '.json' in str(line):
            words = str(line).split('.json')
            filefragment = words[0]
            geturl = copy.deepcopy(basicgeturl)
            trysql = 'SELECT bundleStatus_id,idealName,status FROM BundleStatus WHERE'
            trysql = trysql + ' UUIDJade = \"' + filefragment + '\" AND status=\"JsonMade\"'
            #print(trysql)
            geturl.append(targetupdatebundle + mangle(trysql))
            answer = getoutputsimplecommandtimeout(geturl, 1)
            #danswer = answer.decode("utf-8")
            danswer = massage(answer)
            if danswer == '':
                continue
            if 'FAILURE' in str(danswer):
                ErrorString = ErrorString + ' FAILURE WITH ' + str(filefragment)
                break
            #
            # What happens if I get multiple returns?????  DEBUG
            #print(type(danswer),danswer)
            janswer = json.loads(singletodouble(danswer))
            if len(janswer) <= 0:
                ErrorString = ErrorString + ' No DB info for ' + str(filefragment)
                break
            if len(janswer) > 1:
                ErrorString = ErrorString + ' Multiple active versions of ' + str(filefragment)
                break
            #print(type(janswer),janswer)
            #print(type(janswer[0]),janswer[0])
            bsid = janswer[0]['bundleStatus_id']
            posturl = copy.deepcopy(basicposturl)
            trysql = 'UPDATE BundleStatus SET status=\"PushProblem\" WHERE BundleStatus_id=' + str(bsid)
            #print(trysql)
            posturl.append(targetupdatebundle + mangle(trysql))
            answer = getoutputsimplecommandtimeout(posturl, 1)
            #print(answer)
            command = ['/bin/mv', GLOBUS_PROBLEM_SPACE + '/' + str(line), GLOBUS_PROBLEM_HOLDING]
            outp, erro, code = getoutputerrorsimplecommand(command, 1)
            if int(code) != 0:
                ErrorString = ErrorString + ' Failed to move ' + str(line)

    if ErrorString != '':
        posturl = copy.deepcopy(basicposturl)
        posturl.append(targetsetdumperror + mangle(ErrorString))
        answer = getoutputsimplecommandtimeout(posturl, 1)
    #
    # I have not implemented the rm of the Alert file
    return

# Phase 2	Look for transferred files
# ls GLOBUS_DONE_SPACE
# When you find some, move them to GLOBUS_DONE_HOLDING and
# update their DB entries to PushDone
def Phase2():
    command = ['/bin/ls', GLOBUS_DONE_SPACE]
    ErrorString = ''
    outp, erro, code = getoutputerrorsimplecommand(command, 1)
    if int(code) != 0:
        posturl = copy.deepcopy(basicposturl)
        posturl.append(targetsetdumperror + mangle(' Failed to ls ' + GLOBUS_DONE_SPACE))
        answer = getoutputsimplecommandtimeout(posturl, 1)
        return
    # If here, ls worked ok.
    lines = outp.decode("utf-8").splitlines()
    if len(lines) == 0:
        return	# OK, nothing to do
    for line in lines:
        if '.json' not in str(line):
            continue
        words = str(line).split('.json')
        filefragment = words[0]
        geturl = copy.deepcopy(basicgeturl)
        trysql = 'SELECT bundleStatus_id,idealName,status FROM BundleStatus WHERE'
        trysql = trysql + ' UUIDJade = \"' + filefragment + '\" AND status=\"JsonMade\"'
        #print(trysql)
        geturl.append(targetupdatebundle + mangle(trysql))
        answer = getoutputsimplecommandtimeout(geturl, 1)
        #danswer = answer.decode("utf-8")
        danswer = massage(answer)
        if danswer == '':
            continue
        if 'FAILURE' in str(danswer):
            ErrorString = ErrorString + ' FAILURE WITH ' + str(filefragment)
            break
        #
        # What happens if I get multiple returns?????  DEBUG
        #print(type(danswer),danswer)
        janswer = json.loads(singletodouble(danswer))
        if len(janswer) <= 0:
            ErrorString = ErrorString + ' No DB info for ' + str(filefragment)
            break
        if len(janswer) > 1:
            ErrorString = ErrorString + ' Multiple active versions of ' + str(filefragment)
            break
        #print(type(janswer),janswer)
        #print(type(janswer[0]),janswer[0])
        bsid = janswer[0]['bundleStatus_id']
        posturl = copy.deepcopy(basicposturl)
        trysql = 'UPDATE BundleStatus SET status=\"PushDone\" WHERE BundleStatus_id=' + str(bsid)
        #print(trysql)
        posturl.append(targetupdatebundle + mangle(trysql))
        answer = getoutputsimplecommandtimeout(posturl, 1)
        #print(answer)
        command = ['/bin/mv', GLOBUS_DONE_SPACE + '/' + str(line), GLOBUS_DONE_HOLDING]
        outp, erro, code = getoutputerrorsimplecommand(command, 1)
        if int(code) != 0:
            ErrorString = ErrorString + ' Failed to move ' + str(line)

    if ErrorString != '':
        posturl = copy.deepcopy(basicposturl)
        posturl.append(targetsetdumperror + mangle(ErrorString))
        answer = getoutputsimplecommandtimeout(posturl, 1)
    #
    return


# Phase 3	Look for new local files
# Get list of local bundle tree locations relevant to NERSC transfers
def Phase3():
    geturl = copy.deepcopy(basicgeturl)
    ultimate = '\"NERSC\"'
    geturl.append(targettree + mangle(ultimate))
    answer = getoutputsimplecommandtimeout(geturl, 1)
    danswer = massage(answer)
    ErrorString = ''
    candidateList = []
    if danswer == '':
        print('No place to search')
        return		# Dunno, maybe this was deliberate
    if 'FAILURE' in danswer:
        print(danswer)
        return
    #print(danswer)
    jdiranswer = json.loads(singletodouble(danswer))
    #print(len(jdiranswer), janswer)
    for js in jdiranswer:
        dirs = js['treetop']
        command = ['/bin/find', dirs, '-type', 'f']
        outp, erro, code = getoutputerrorsimplecommand(command, 30)
        if int(code) != 0:
            print(' Failed to find/search ' + str(dirs))
            ErrorString = ErrorString + ' Failed to find/search ' + str(dirs)
        if len(outp) == 0:
            continue
        #print(outp)
        lines = outp.splitlines()
        for t in lines:
            if '.zip' in str(t):
                candidateList.append(t.decode("utf-8"))
    if len(candidateList) <= 0:
        return
    # OK, found a curious limit with sqlite3.  I cannot use
    #  more than 25 string entries in the localName IN () query
    # So, I have to break it up into multiple queries
    inchunkCount = 0
    jsonList = []
    nomatch = []
    for p in candidateList:
        if inchunkCount == 0:
            bigquery = 'status!=\"Abort\" AND localName IN ('
        bigquery = bigquery + '\"' + p + '\",'
        inchunkCount = inchunkCount + 1
        if inchunkCount > 24:	# Avoid count limit
            inchunkCount = 0
            # replace the last comma with a right parenthesis
            bigq = bigquery[::-1].replace(',', ')', 1)[::-1]
            #print('bigq=', bigq)
            geturl = copy.deepcopy(basicgeturl)
            geturl.append(targetfindbundles + mangle(bigq))
            answer = getoutputsimplecommandtimeout(geturl, 3)
            danswer = massage(answer)
            if len(danswer) < 1:
                continue
            if 'Not Found' in danswer:
                print('Not Found', danswer)
                #print(bigq)
                continue
            else:
                try:
                    jjanswer = json.loads(singletodouble(danswer))
                except:
                    print('Failed to translate json code', danswer)
                    return
                for js in jjanswer:
                    jsonList.append(js)
        #
    if inchunkCount > 0:
        bigq = bigquery[::-1].replace(',', ')', 1)[::-1]
        #print('bigq=', bigq)
        geturl = copy.deepcopy(basicgeturl)
        geturl.append(targetfindbundles + mangle(bigq))
        answer = getoutputsimplecommandtimeout(geturl, 3)
        danswer = massage(answer)
        #print('danswer length=', len(danswer))
        if len(danswer) > 1:
            if 'Not Found' in danswer:
                print('Not Found', danswer)
                #print('bigq=', bigq)
                return
            else:
                try:
                    jjanswer = json.loads(singletodouble(danswer))
                except:
                    print('Failed to translate json code', danswer)
                    return
                for js in jjanswer:
                    jsonList.append(js)

    if len(jsonList) == 0:
        for p in candidateList:
            nomatch.append(p)
    else:
        for p in candidateList:
            mfound = False
            for js in jsonList:
                if p == js['localName']:
                    mfound = True
                    break
            if not mfound:
                nomatch.append(p)
    if len(nomatch) == 0:
        #print(len(nomatch), 'No matches found')
        return		# All present and accounted for
    #
    # OK, now check that the info is in the database.  Connect to
    # jade-lta-db now.  Use the .my.cnf so I don't expose passwords
    getdbgen()
    cursor = returndbgen()
    #
    # It seems reasonabl to think that a particular file will only
    # exist once in the jade-lta-db.  Unique UUID and all..
    for filex in nomatch:
        mybasename = os.path.basename(filex)
        reply = doOperationDBTuple(cursor, 'SELECT * FROM jade_bundle WHERE bundle_file=\"' + mybasename + '\"', 'Phase3')
        if 'ERROR' in reply:
            continue
        #print(reply[0]['size'], reply[0]['checksum'])
        #
        for js in jdiranswer:
            dirs = js['treetop']
            nc = filex.split(dirs)
            if len(nc) == 2:
                insdict = '\{\'localName\' : \'' + filex+ '\', \'idealName\' : \'' + nc[1] + '\', \'size\' : \'' + str(reply[0]['size'])
                insdict = insdict + '\', \'checksum\' : \'' + str(reply[0]['checksum']) + '\', \'UUIDJade\' : \'\', \'UUIDGlobus\' : \'\','
                insdict = insdict + ' \'useCount\' : \'1\', \'status\' : \'Untouched\'\}'
                #print(mangle(str(insdict)))
                posturl = copy.deepcopy(basicposturl)
                posturl.append(targetaddbundle + mangle(str(insdict)))
                answer = getoutputsimplecommandtimeout(posturl, 1)
                if 'OK' not in str(answer):
                    print(str(insdict), answer)
                continue
    return
# Foreach tree
#   Find bundle files in each tree
#   Accumulate information in locallist
# If locallist is not empty
#   Build a query for contents of locallist
# Query BundleStatus for these
# Parse the return:
# If the file is not in BundleStatus, add it as 'Untouched'
# Done with phase 3


###########
# Phase 4	Submit new files
def Phase4():
    geturl = copy.deepcopy(basicgeturl)
    geturl.append(targetdumpinfo)
    answer = massage(getoutputsimplecommandtimeout(geturl, 1))
    janswer = json.loads(singletodouble(answer))
    # I know a priori there is only one return line
    status = janswer['status']
    if status != 'Run':
        #print('No run')
        return		# Don't load more in the globus pipeline
    geturl = copy.deepcopy(basicgeturl)
    #geturl.append(targetuntouchedall)
    geturl.append(targetuntouchedall)
    #print(geturl)
    answer = massage(getoutputsimplecommandtimeout(geturl, 1))
    #print(answer)
    if 'DOCTYPE HTML PUBLIC' in answer or 'FAILURE' in answer:
        print('Error in answer')
        return
    # There may be multiple entries here
    #print(answer)
    jjanswer = json.loads(singletodouble(answer))
    numwaiting = len(jjanswer)
    #print(numwaiting)
    if numwaiting <= 0:
        #print('None waiting')
        return		# Nothing to do
    command = ['/bin/ls', GLOBUS_RUN_SPACE]
    answerlsb, errorls, codels = getoutputerrorsimplecommand(command, 1)
    #print('code=', str(codels))
    if int(codels) != 0:
        print('Cannot ls the', GLOBUS_RUN_SPACE)
        return		# Something went wrong, try later
    answerls = massage(answerlsb)
    if 'TIMEOUT' in answerls:
        print('ls timed out')
        return		# Something went wrong, try later
    lines = answerls.splitlines()
    if len(lines) >= GLOBUS_INFLIGHT_LIMIT:
        #print('Too busy')
        return		# Too busy for more
    limit = GLOBUS_INFLIGHT_LIMIT - len(lines)
    if limit > numwaiting:
        limit = numwaiting
    #print('limit=', str(limit), str(len(lines)), str(numwaiting))
    for countup in range(0, limit):
        try:
            js = jjanswer[countup]
            bundle_id = js['bundleStatus_id']
            localName = js['localName']
            idealName = js['idealName']
        except:
            print('Failure in unpacking json info for #', str(countup))
            return
        jadeuuid = str(uuid.uuid4())
        localDir = os.path.dirname(localName) + '/'
        idealDir = os.path.dirname(idealName) + '/'
        remotesystem = 'NERSC'
        jsonContents = globusjson(jadeuuid, localDir, remotesystem, idealDir)
        jsonName = jadeuuid + '.json'
        try:
            fileout = open(GLOBUS_RUN_SPACE + '/' + jsonName, 'w')
            fileout.write(jsonContents)
            fileout.close()
        except:
            print('Failed to open/write/close ' + jsonName)
            return	# Try again later
        # Now update the BundleStatus
        posturl = copy.deepcopy(basicposturl)
        trysql = 'UPDATE BundleStatus SET status=\"JsonMade\",UUIDJade=\"{}\" WHERE BundleStatus_id='.format(jadeuuid) + str(bundle_id)
        #print(trysql)
        posturl.append(targetupdatebundle + mangle(trysql))
        answer = getoutputsimplecommandtimeout(posturl, 1)
        # Not checking answer is probably a bad thing hereJNB
        continue
    return
# Check CandC for go/nogo
# If Error or Halt or Drain, done w/ phase 4
# Query BundleStatus for the bundlelist of 'Untouched' bundles,
# starting with the oldest
# If == 0, done w/ phase 4
# Query BundleStatus for the count of JsonMade bundles
# If > GLOBUS_INFLIGHT_LIMIT, done w/ phase 4
# foreach bundle in the bundlelist
#   if the running count > GLOBUS_INFLIGHT_LIMIT, done w/ phase 4
#   Create a .json file for this bundle in GLOBUS_RUN_SPACE
#   update the BundleStatus for this bundle to 'JsonMade' 
#
# Check CandC for Run or Drain
# Get list of files with NERSCClean set
# foreach file in that list
#   check if local file exists
#     if yes, execute a delete
#     reset the status to LocalDeleted
Phase5()
    geturl = copy.deepcopy(basicgeturl)
    geturl.append(targetdumpinfo)
    answer = massage(getoutputsimplecommandtimeout(geturl, 1))
    janswer = json.loads(singletodouble(answer))
    # I know a priori there is only one return line
    status = janswer['status']
    if status != 'Run' and status != 'Drain':
        return		# Don't load more in the globus pipeline
    #
    geturl = copy.deepcopy(basicgeturl)
    geturl.append(targetfindbundles + mangle('status=\"NERSCClean\"'))
    answer = massage(getoutputsimplecommandtimeout(geturl, 1))
    if 'DOCTYPE HTML PUBLIC' in answer or 'FAILURE' in answer:
        print('Phase 5 failure with', geturl)
        return
    if len(answer) = 0:
        return	# Nothing to do
    jjanswer = json.loads(singletodouble(answer))
    numwaiting = len(jjanswer)
    # Sanity check
    if numwaiting <= 0:
        # This should not happen, but maybe the json isn't understood
        print('Phase 5 json is empty', str(answer))
        return
    for js in jjanswer:
        try:
            localname = js['localName']
        except:
            print('Phase 5: problem with getting info from', js)
            continue
        try:
            command = [ls, localname]
            outp, erro, code = getoutputerrorsimplecommand(command, 1)
            if int(code) == 0:
                command = [rm, localname]
                outp, erro, code = getoutputerrorsimplecommand(command, 1)
        except:
            print('Phase 5: I do not see the file, or else deleting it fails', localname)
            continue
        key = js['bundleStatus_id']
        posturl = copy.deepcopy(basicposturl)
        comd = 'UPDATE BundleStatus set status=\"LocalDeleted\" WHERE updateBundle_id={}.format(key)
        posturl.append(targetupdatebundle + mangle(comd))
        answer = getoutputsimplecommandtimeout(posturl, 1)
        if len(answer) > 0:
            print('Phase 5: failed to set status=LocalDeleted for', localname)
            continue 
    return
Phase0()
print('Done w/0, checking space usage')
Phase1()
print('Done w/1, checking for jade failed transfers')
Phase2()
print('Done w/2 checking for jade completed transfers')
Phase3()
print('Done w/3 checking for new local files to transfer')
Phase4()
print('Done w/4 submitting new files to jade')
Phase5()
print('Done w/5 deleting local copies of successful transfers')
