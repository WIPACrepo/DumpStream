import sys
import datetime
#SUPERIMPORT IMPORT_utils.py

#SUPERIMPORT CODE_utils.py

USEHEARTBEATS = False

def deltaT(oldtimestring):
    current = datetime.datetime.now()
    try:
        oldt = datetime.datetime.strptime(oldtimestring, '%Y-%m-%d %H:%M:%S')
        difference = current - oldt
        delta = int(difference.seconds/60 + difference.days*60*24)
    except:
        delta = -1
    return delta

########################################################
# Main


####
# NERSC status   
geturl = copy.deepcopy(basicgeturl)
geturl.append(targetnerscinfo)
outp, erro, code = getoutputerrorsimplecommand(geturl, 1)
nstats = ''
if int(code) != 0:
    nstats = 'DB Failure'
else:
    #print(outp)
    my_json = json.loads(singletodouble(outp.decode('utf-8')))
    nstats = (my_json['status'] + ' | ' + my_json['nerscError'] + ' | '
              + str(my_json['nerscSize']) + ' | ' + str(my_json['lastChangeTime'])
              + '  ' + str(deltaT(str(my_json['lastChangeTime']))))
logit('NERSCStatus= ', nstats)


####
# NERSC token status
geturl = copy.deepcopy(basicgeturl)
geturl.append(targettokeninfo)
outp, erro, code = getoutputerrorsimplecommand(geturl, 1)
nstats = ''
if int(code) != 0:
    nstats = 'DB Failure'
else:
    my_json = json.loads(singletodouble(outp.decode('utf-8')))
    tname = 'NULL'
    if my_json['hostname'] != '':
        tname = my_json['hostname']
    nstats = tname + ' at ' + str(my_json['lastChangeTime'])
    nstats = nstats + '  ' + str(deltaT(str(my_json['lastChangeTime'])))
logit('NERSCToken= ', nstats)

####
# NERSC heartbeats
if USEHEARTBEATS:
    geturl = copy.deepcopy(basicgeturl)
    geturl.append(targetheartbeatinfo)
    outp, erro, code = getoutputerrorsimplecommand(geturl, 1)
    nstats = ''
    if int(code) != 0:
        nstats = 'DB Failure'
    else:
        trialbunch = stringtodict(str(outp))
        #print(trialbunch)
        nstats = 'Beats: '
        for chunk in trialbunch:
            #print(chunk)
            my_json = json.loads(singletodouble(chunk))  #outp.decode('utf-8')))
            nstats = nstats + '| ' + my_json['hostname'] + '::' + str(my_json['lastChangeTime'])
            nstats = nstats + '  ' + str(deltaT(str(my_json['lastChangeTime'])))
    logit('NERSCHeartbeats= ', nstats)


####
# local status   
geturl = copy.deepcopy(basicgeturl)
geturl.append(targetdumpinfo)
outp, erro, code = getoutputerrorsimplecommand(geturl, 1)
nstats = ''
if int(code) != 0:
    nstats = 'DB Failure'
else:
    #print(outp)
    my_json = json.loads(singletodouble(outp.decode('utf-8')))
    nstats = (my_json['status'] + ' | ' + my_json['bundleError'] + ' | '
              + str(my_json['bundlePoolSize']) + ' | ' + str(my_json['lastChangeTime']))
    nstats = nstats + '  ' + str(deltaT(str(my_json['lastChangeTime'])))
logit('LocalStatus= ', nstats)


####
# How many bundles have each status?
# I will probably get fancier later.  For now, just this.
nstats = ''
for opt in BundleStatusOptions:
    geturl = copy.deepcopy(basicgeturl)
    geturl.append(targetupdatebundle + mangle('SELECT COUNT(*) FROM BundleStatus where status = \"' + opt + '\"'))
    outp, erro, code = getoutputerrorsimplecommand(geturl, 1)
    #print(outp)
    if int(code) != 0:
        nstats = nstats + 'DB Failure'
    else:
        my_json = json.loads(singletodouble(outp.decode('utf-8')))
        js = my_json[0]
        nstats = nstats + ' | ' + opt + ':' + str(js['COUNT(*)'])
logit('BundleStatusCounts= ', nstats)

####
# Do we have duplicate entries?

doubles = -1
ndoubles = ''
geturl = copy.deepcopy(basicgeturl)
geturl.append(targetupdatebundle + mangle('SELECT status,localName,bundleStatus_id FROM BundleStatus where status not in (\"Abort\",\"LocalDeleted\")'))
outp, erro, code = getoutputerrorsimplecommand(geturl, 1)
if int(code) != 0:
    ndoubles = 'DB Failure'
else:
    doubles = 0
    bunch = []
    my_json = json.loads(singletodouble(outp.decode('utf-8')))
    for js in my_json:
        bunch.append([os.path.basename(js['localName']), str(js['status']), str(js['bundleStatus_id'])])
    for b in bunch:
        ln = b[0]
        for c in bunch:
            if c != b:
                if ln == c[0]:
                    doubles = doubles + 1
    doubles = doubles / 2
    ndoubles = str(doubles)
# do I want to log this at all if there's no problem?
if doubles != 0:
    logit('Duplicate bundle transfers=', ndoubles)
