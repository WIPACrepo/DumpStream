# DumpControl.py.base
import sys
#SUPERIMPORT IMPORT_utils.py
#
##SUPERIMPORT CODE_utils.py

##########
# Utilities:
#  1) Check a slot
#    a) Is it readable?
#    b) What is its UUID?  The .json file tells us
#    c) Get the wanted trees and parse for the top directories
#    d) Organize the groups by top directory
#    e) Look in those top directories to find the year(s) for each
#    f) Use those lists and those years to create a new list of
#       rsync sources, and return this and the UUID
#  2) Create a rsync bash script using the UUID and rsync sources
#    a) New file w/ UUID.sh name and a list
#    b) Submit this (do I want the process ID too?)



#################################################################
# INVENTORY CODE
#
###
# Give top directories from a list
def GiveTops(desiredtrees):
    if len(desiredtrees) <= 0:
        return []
    toplist = []
    for tree in desiredtrees:
        tip = tree.split('/')[0]
        if tip not in toplist:
            toplist.append(tip)
    return toplist

###
# Inventory a slot.  Pass it the json for the slot (has old info)
# and the list of trees we want to archive.  YEAR must be
# replaced with the actual year(s) found
def InventoryOneFull(slotjson):
    # First find out what trees we want to read
    geturl = copy.deepcopy(basicgeturl)
    geturl.append(targetdumpingwantedtrees)
    outp, erro, code = getoutputerrorsimplecommand(geturl, 1)
    if int(code) != 0 or 'FAILURE' in str(outp):
        print('Get trees failure', geturl, outp)
        sys.exit(0)
    desiredtrees = []
    for h in str(outp):
        desiredtrees.append(h)

    if len(desiredtrees) <= 0:
        return []
    #
    toplist = GiveTops(desiredtrees)
    #
    # If no trees to read, why bother?
    #
    try:
        slotlocation = slotjson['name']
    except:
        print('InventoryOne: problem with slotjson', slotjson)
        return []
    #
    # Note that even if the disk is not mounted, the mountpoint
    #  is still there, and will be "readable" if not populated
    # Bail if it is empty--probably not mounted
    #
    command = ['/bin/ls', slotlocation]
    outp, erro, code = getoutputerrorsimplecommand(command, 1)
    if int(code) != 0 or len(outp) <= 1:
        print('Cannot read the disk in', slotlocation)
        return []	# Do I want to set an error?
    answer = str(outp.decode('utf-8'))
    for toplevel in answer.split():
        #print(toplevel)
        if len(toplevel.split('-')) == 5:
            diskuuid = toplevel
    #
    # Generate the list of directories to rsync
    dirstoscan = []
    for tip in toplist:
        if tip in answer.split():
            command = ['/bin/ls', slotlocation + '/' + tip]
            outp, erro, code = getoutputerrorsimplecommand(command, 1)
            if code != 0:
                continue	# May not be present, do not worry about it
            tipyearlist = []
            for y in outp.split():
                tipyearlist.append(y)
            for dt in desiredtrees:
                if tip in dt:
                    words = dt.split('YEAR')
                    for y in tipyearlist:
                        dirstoscan.append(words[0] + y + words[1])
    #for j in dirstoscan:
    #    print(j)
    return [diskuuid, dirstoscan]

####
# Get the UUID, if this is readable, for use with slot
# management
def InventoryOne(slotjson):
    #
    try:
        slotlocation = slotjson['name']
    except:
        print('InventoryOne: problem with slotjson', slotjson)
        return []
    #
    command = ['/bin/ls', slotlocation]
    outp, erro, code = getoutputerrorsimplecommand(command, 1)
    if int(code) != 0 or len(outp) <= 1:
        print('Cannot read the disk in', slotlocation)
        return []	# Do I want to set an error?
    answer = str(outp.decode('utf-8'))
    diskuuid = ''
    for toplevel in answer.split():
        #print(toplevel)
        if len(toplevel.split('-')) == 5:
            diskuuid = toplevel
    return diskuuid


####
# Go through all the slots and see what the UUID is in them
# Connect information between SlotContents and PoleDisk
#  entries
def InventoryAll():
    geturl = copy.deepcopy(basicgeturl)
    geturl.append(targetdumpingslotcontents)
    outp, erro, code = getoutputerrorsimplecommand(geturl, 1)
    if int(code) != 0:
        print('SlotContents failure', geturl, outp)
        sys.exit(0)
    my_json = json.loads(singletodouble(outp.decode('utf-8')))
    geturl = copy.deepcopy(basicgeturl)
    geturl.append(targetdumpingdumptarget)
    outp, erro, code = getoutputerrorsimplecommand(geturl, 1)
    if int(code) != 0 or 'FAILURE' in str(outp):
        print('get dump target failure', geturl, outp)
        sys.exit(0)
    targetarea = str(outp)
    #
    for js in my_json:
        # First check if the slot is disabled
        if js['poledisk_id'] < 0:
            continue
        # Now inventory the slot--get the UUID of the disk, if available
        diskuuid = InventoryOne(js)
        if diskuuid == '':
            print('Got nothing for', js['slotnumber'])
            continue
        #
        # Link SlotContents to the new PoleDisk
        stuffforpd = {"diskuuid":diskuuid, "slotnumber":js['slotnumber'], "targetArea":targetarea, "status":"Inventoried"}
        posturl = copy.deepcopy(basicposturl)
        #posturl.append(targetdumpingsetslotcontents + mangle(str(stuffforpd)))
        posturl.append(targetdumpingsetslotcontents + urllib.parse.urlencode(stuffforpd))
        outp, erro, code = getoutputerrorsimplecommand(posturl, 1)
        if int(code) != 0 or 'FAILURE' in str(outp):
            print('Load new PoleDisk failed', posturl, outp, erro, code)
            sys.exit(0)
        #
        # OK, now I want to read back what I wrote so I get the new poledisk_id
        geturl = copy.deepcopy(basicgeturl)
        geturl.append(targetdumpingpolediskuuid + mangle(diskuuid))
        outp, erro, code = getoutputerrorsimplecommand(geturl, 1)
        if len(outp) == 0 or 'FAILURE' in str(outp):
            print('Retrive PoleDisk info failed', geturl, outp, erro, code)
            sys.exit(0)
        soutp = outp.decode('utf-8')
        try:
            djson = json.loads(singletodouble(soutp))
            js = djson[0]
            case = mangle(str(js['slotnumber']) + ' ' + str(js['poledisk_id']))
        except:
            print('Retrieve of new poledisk_id failed', soutp)
            sys.exit(0)
        #
        # Armed w/ the new poledisk_id, update the slot contents
        posturl = copy.deepcopy(basicposturl)
        posturl.append(targetdumpingsetslotcontents + case)
        outp, erro, code = getoutputerrorsimplecommand(posturl, 1)
        if len(outp) != 0 or 'FAILURE' in str(outp):
            print('Update SlotContents info failed', posturl, outp)
            sys.exit(0)

    return

#########################################################
# JOB CHECK CODE
def JobInspectAll():
    # First get a list of all the nominally active slots
    geturl = copy.deepcopy(basicgeturl)
    geturl.append(targetdumpinggetactive)
    outp, erro, code = getoutputerrorsimplecommand(geturl, 1)
    if int(code) != 0:
        print('JobInspectAll: active slots check failure', geturl, outp)
        sys.exit(0)
    my_json = json.loads(singletodouble(outp.decode('utf-8')))
    # Load the relevant info up:
    expected = []
    for js in my_json:
        expected.append([js['diskuuid'], js['slotnumber'], js['dateBegun'], js['poledisk_id']])
    # Suppose expected is empty and the list of jobs isn't?
    # Flag an error
    #
    #  I expect that the active slot info will be a superset
    #  of the jobs found.  If they match, and the count is
    #  equal to or higher than DUMPING_LIMIT,
    #  don't bother doing anything.
    #  Inspecting the dateBegun vs today might be useful, though
    #
    # Now find out what jobs are active
    command = ['/usr/bin/ps', 'aux']
    outp, erro, code = getoutputerrorsimplecommand(command, 1)
    if int(code) != 0:
        print('JobInspectAll: pstree failed', outp, erro, code)
        sys.exit(0)
    candidate = []
    listing = outp.decode('utf-8').splitlines()
    for line in listing:
        if 'DUMPDISK' in line:
            candidate.append(line)
    # Inspect if the expected jobs are still running
    matching = []
    notmatched = []
    for v in expected:
        found = False
        for c in candidate:
            if v[0] in c:	# The uuid.  Will there be truncation?
                matching.append(v)
                found = True
                continue
        if not found:
            notmatched.append(v)
    return expected, candidate, matching, notmatched

####
# Check if the log space is getting full
def CheckLogSpace():
    command = ['/usr/bin/df', '-h', DUMPING_LOG_SPACE]
    outp, erro, code = getoutputerrorsimplecommand(command, 1)
    if int(code) != 0:
        print('CheckLogSpace failed', outp, erro, code, DUMPING_LOG_SPACE)
        sys.exit(0)
    percent = int(outp.decode('utf-8').split()[-2].split('%')[0])
    return percent < 90

####
# Decide whether a new job is needed, or whether an old job is done
def JobDecision():
    # Inspect what's out there
    expected, candidate, matching, notmatched = JobInspectAll()
    # Sanity check
    if len(expected) < len(candidate):
        print('JobDecision: we have more jobs running than expected!', len(expected), len(candidate))
        sys.exit(0)
    #
    # Look for completed jobs and flag them
    for jdone in notmatched:
        # First make sure nothing is wrong
        # I expect a script in DUMPING_LOG_SPACE/DUMPDISK_${UUID} and a log file
        # in DUMPING_LOG_SPACE/DUMPDISK_${UUID}.log
        tentative = DUMPING_LOG_SPACE + '/DUMPDISK_' + jdone[0] + '.log'
        command = ['/usr/bin/tail', '-n1', tentative]
        outp, erro, code = getoutputerrorsimplecommand(command, 1)
        if int(code) != 0:
            print('JobDecision failed to tail', tentative)
            sys.exit(0)
        answerline = outp.decode('utf-8')
        #
        # Sanity checking--expect "SUMMARY 5 5" or however many rsyncs were done
        summaryinfo = answerline.split()
        if summaryinfo[0] != 'SUMMARY':
            print('JobDecision summary info line missing for', tentative)
            print('It may have crashed.  Rerun the rsync?')
            sys.exit(0)
        try:
            numtried = int(summaryinfo[1])
            numsucceeded = int(summaryinfo[2])
        except:
            print('JobDecision summary info line corrupt for', tentative)
            print('It may have crashed.  Rerun the rsync?', answerline)
            sys.exit(0)
        if numtried != numsucceeded:
            print('JobDecision summary line info shows problems for', tentative)
            print('Rerun the rsyns?', answerline)
            sys.exit(0)
        posturl = copy.deepcopy(basicposturl).append(targetdumpingpolediskdone + mangle(js['poledisk_id']))
        outp, erro, code = getoutputerrorsimplecommand(posturl, 1)
        if int(code) != 0 or 'FAILURE' in str(outp):
            print('Set status of PoleDisk failed', js['poledisk_id'])
            sys.exit(0)
    # Done flagging completed jobs  Nothing to do?
    # BEWARE:  Countup is all I use for determining if a directory is ready--I don't check
    # the size!!
    return ''

###########
#
#InventoryAll()
jobinformation = JobInspectAll()
